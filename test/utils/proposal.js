const { ethers } = require("hardhat");

const IF_SET_PAUSED = new ethers.Interface(["function setJoinPausedDAO(bool)"]);
const IF_WT = new ethers.Interface(["function withdrawTreasuryDAO(address,address,uint256,string)"]);
const IF_UC = new ethers.Interface([
  "function updateConfigDAO(uint256,bool,uint256,uint256,uint256)"
]);
const IF_DISBAND = new ethers.Interface(["function disbandTreasuryDAO(address)"]);
const IF_DISBAND_LEGACY = new ethers.Interface(["function disbandTreasuryDAO()"]);
const IF_SET_METADATA = new ethers.Interface(["function setTemplMetadataDAO(string,string,string)"]);
const IF_SET_PROPOSAL_FEE = new ethers.Interface(["function setProposalCreationFeeBpsDAO(uint256)"]);
const IF_SET_REFERRAL_SHARE = new ethers.Interface(["function setReferralShareBpsDAO(uint256)"]);
const IF_SET_CURVE = new ethers.Interface(["function setEntryFeeCurveDAO((uint8,uint32),uint256)"]);

async function createProposal({ templ, signer, title, description: proposalDescription, callData, votingPeriod }) {
  const conn = templ.connect(signer);
  try {
    const [paused] = IF_SET_PAUSED.decodeFunctionData("setJoinPausedDAO", callData);
    const tx = await conn.createProposalSetJoinPaused(paused, votingPeriod, title, proposalDescription);
    return await tx.wait();
  } catch {}
  try {
    const [token, recipient, amount, reason] = IF_WT.decodeFunctionData("withdrawTreasuryDAO", callData);
    const tx = await conn.createProposalWithdrawTreasury(
      token,
      recipient,
      amount,
      reason,
      votingPeriod,
      title,
      proposalDescription
    );
    return await tx.wait();
  } catch {}
  try {
    const [newFee, updateSplit, burnBps, treasuryBps, memberPoolBps] =
      IF_UC.decodeFunctionData("updateConfigDAO", callData);
    const tx = await conn.createProposalUpdateConfig(
      newFee,
      burnBps,
      treasuryBps,
      memberPoolBps,
      updateSplit,
      votingPeriod,
      title,
      proposalDescription
    );
    return await tx.wait();
  } catch {}
  try {
    const [token] = IF_DISBAND.decodeFunctionData("disbandTreasuryDAO", callData);
    const tx = await conn.createProposalDisbandTreasury(token, votingPeriod, title, proposalDescription);
    return await tx.wait();
  } catch {}
  try {
    IF_DISBAND_LEGACY.decodeFunctionData("disbandTreasuryDAO", callData);
    const accessToken = await templ.accessToken();
    const tx = await conn.createProposalDisbandTreasury(accessToken, votingPeriod, title, proposalDescription);
    return await tx.wait();
  } catch {}
  try {
    const [name, metadataDescription, logoLink] = IF_SET_METADATA.decodeFunctionData(
      "setTemplMetadataDAO",
      callData
    );
    const tx = await conn.createProposalUpdateMetadata(
      name,
      metadataDescription,
      logoLink,
      votingPeriod,
      title,
      proposalDescription
    );
    return await tx.wait();
  } catch {}
  try {
    const [feeBps] = IF_SET_PROPOSAL_FEE.decodeFunctionData("setProposalCreationFeeBpsDAO", callData);
    const tx = await conn.createProposalSetProposalFeeBps(feeBps, votingPeriod, title, proposalDescription);
    return await tx.wait();
  } catch {}
  try {
    const [referralBps] = IF_SET_REFERRAL_SHARE.decodeFunctionData("setReferralShareBpsDAO", callData);
    const tx = await conn.createProposalSetReferralShareBps(referralBps, votingPeriod, title, proposalDescription);
    return await tx.wait();
  } catch {}
  try {
    const [curve, baseEntryFee] = IF_SET_CURVE.decodeFunctionData("setEntryFeeCurveDAO", callData);
    const tx = await conn.createProposalSetEntryFeeCurve(curve, baseEntryFee, votingPeriod, title, proposalDescription);
    return await tx.wait();
  } catch {}
  throw new Error("Unsupported callData for createProposal adapter");
}

module.exports = { createProposal };
module.exports.attachCreateProposalCompat = function(templ) {
  const origConnect = templ.connect.bind(templ);
  templ.connect = (signer) => {
    const instance = origConnect(signer);
    instance.createProposal = (title, description, callData, votingPeriod) =>
      createProposal({ templ, signer, title, description, callData, votingPeriod });
    return instance;
  };
  return templ;
};

module.exports.attachProposalMetadataShim = function(templ) {
  const DEFAULT_META = ["Autogenerated title", "Autogenerated description"];
  const expectedArgs = new Map([
    ['createProposalSetJoinPaused', 4],
    ['createProposalUpdateConfig', 9],
    ['createProposalWithdrawTreasury', 7],
    ['createProposalDisbandTreasury', 4],
    ['createProposalChangePriest', 4],
    ['createProposalSetDictatorship', 4],
    ['createProposalSetMaxMembers', 4],
    ['createProposalUpdateMetadata', 6],
    ['createProposalSetProposalFeeBps', 4],
    ['createProposalSetReferralShareBps', 4],
    ['createProposalSetEntryFeeCurve', 5]
  ]);

  const wrapInstance = (instance) => {
    if (!instance || instance.__templMetadataShimApplied) return;
    Object.defineProperty(instance, '__templMetadataShimApplied', { value: true, enumerable: false });

    for (const [key, totalArgs] of expectedArgs.entries()) {
      const original = instance[key];
      if (typeof original !== 'function') continue;

      instance[key] = function (...args) {
        let overrides;
        if (args.length && isOverrides(args[args.length - 1])) {
          overrides = args.pop();
        }

        if (args.length < totalArgs) {
          const missing = totalArgs - args.length;
          const additions = [];
          for (let i = 0; i < missing; i++) {
            additions.push(DEFAULT_META[i % DEFAULT_META.length]);
          }
          args.push(...additions);
        }

        if (overrides) args.push(overrides);
        return original.apply(this, args);
      };
    }
  };

  const isOverrides = (value) => {
    if (!value || typeof value !== 'object' || Array.isArray(value)) return false;
    const keys = Object.keys(value);
    if (keys.length === 0) return false;
    const overrideKeys = new Set(['gasLimit', 'gasPrice', 'value', 'nonce', 'maxFeePerGas', 'maxPriorityFeePerGas']);
    return keys.some((k) => overrideKeys.has(k));
  };

  const originalConnect = templ.connect.bind(templ);
  templ.connect = (signer) => {
    const instance = originalConnect(signer);
    wrapInstance(instance);
    return instance;
  };

  wrapInstance(templ);
  return templ;
};
