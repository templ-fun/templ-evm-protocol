const { ethers } = require("hardhat");

const IF_SET_PAUSED = new ethers.Interface(["function setPausedDAO(bool)"]);
const IF_WT = new ethers.Interface(["function withdrawTreasuryDAO(address,address,uint256,string)"]);
const IF_UC = new ethers.Interface([
  "function updateConfigDAO(address,uint256,bool,uint256,uint256,uint256)"
]);
const IF_DISBAND = new ethers.Interface(["function disbandTreasuryDAO(address)"]);
const IF_DISBAND_LEGACY = new ethers.Interface(["function disbandTreasuryDAO()"]);

async function createProposal({ templ, signer, title, description, callData, votingPeriod }) {
  const conn = templ.connect(signer);
  try {
    const [paused] = IF_SET_PAUSED.decodeFunctionData("setPausedDAO", callData);
    const tx = await conn.createProposalSetPaused(paused, votingPeriod, title, description);
    return await tx.wait();
  } catch {}
  try {
    const [token, recipient, amount, reason] = IF_WT.decodeFunctionData("withdrawTreasuryDAO", callData);
    const tx = await conn.createProposalWithdrawTreasury(token, recipient, amount, reason, votingPeriod, title, description);
    return await tx.wait();
  } catch {}
  try {
    const [, newFee, updateSplit, burnPercent, treasuryPercent, memberPoolPercent] =
      IF_UC.decodeFunctionData("updateConfigDAO", callData);
    const tx = await conn.createProposalUpdateConfig(
      newFee,
      burnPercent,
      treasuryPercent,
      memberPoolPercent,
      updateSplit,
      votingPeriod,
      title,
      description
    );
    return await tx.wait();
  } catch {}
  try {
    const [token] = IF_DISBAND.decodeFunctionData("disbandTreasuryDAO", callData);
    const tx = await conn.createProposalDisbandTreasury(token, votingPeriod, title, description);
    return await tx.wait();
  } catch {}
  try {
    IF_DISBAND_LEGACY.decodeFunctionData("disbandTreasuryDAO", callData);
    const accessToken = await templ.accessToken();
    const tx = await conn.createProposalDisbandTreasury(accessToken, votingPeriod, title, description);
    return await tx.wait();
  } catch {}
  throw new Error("Unsupported callData for createProposal adapter");
}

module.exports = { createProposal };
module.exports.attachCreateProposalCompat = function(templ) {
  const origConnect = templ.connect.bind(templ);
  templ.connect = (signer) => {
    const instance = origConnect(signer);
    instance.createProposal = (title, description, callData, votingPeriod) =>
      createProposal({ templ, signer, title, description, callData, votingPeriod });
    return instance;
  };
  return templ;
};

module.exports.attachProposalMetadataShim = function(templ) {
  const DEFAULT_META = ["Autogenerated title", "Autogenerated description"];
  const expectedArgs = new Map([
    ['createProposalSetPaused', 4],
    ['createProposalUpdateConfig', 8],
    ['createProposalWithdrawTreasury', 7],
    ['createProposalDisbandTreasury', 4],
    ['createProposalChangePriest', 4],
    ['createProposalSetDictatorship', 4],
    ['createProposalSetMaxMembers', 4]
  ]);

  const wrapInstance = (instance) => {
    if (!instance || instance.__templMetadataShimApplied) return;
    Object.defineProperty(instance, '__templMetadataShimApplied', { value: true, enumerable: false });

    for (const [key, totalArgs] of expectedArgs.entries()) {
      const original = instance[key];
      if (typeof original !== 'function') continue;

      instance[key] = function (...args) {
        let overrides;
        if (args.length && isOverrides(args[args.length - 1])) {
          overrides = args.pop();
        }

        if (args.length < totalArgs) {
          const missing = totalArgs - args.length;
          const additions = [];
          for (let i = 0; i < missing; i++) {
            additions.push(DEFAULT_META[i % DEFAULT_META.length]);
          }
          args.push(...additions);
        }

        if (overrides) args.push(overrides);
        return original.apply(this, args);
      };
    }
  };

  const isOverrides = (value) => {
    if (!value || typeof value !== 'object' || Array.isArray(value)) return false;
    const keys = Object.keys(value);
    if (keys.length === 0) return false;
    const overrideKeys = new Set(['gasLimit', 'gasPrice', 'value', 'nonce', 'maxFeePerGas', 'maxPriorityFeePerGas']);
    return keys.some((k) => overrideKeys.has(k));
  };

  const originalConnect = templ.connect.bind(templ);
  templ.connect = (signer) => {
    const instance = originalConnect(signer);
    wrapInstance(instance);
    return instance;
  };

  wrapInstance(templ);
  return templ;
};
